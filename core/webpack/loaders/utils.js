const { parse } = require("@vue/component-compiler-utils");
const compiler = require("vue-template-compiler");

/**
 * Returns the SFC descriptor for a given SFC sourcecode
 * @param source
 */
const toDescriptor = (source) =>{
    var desc = parse({
        source: source,
        compiler,
        needMap: false
    });
    // Remove comment lines at beginning of script block that were generated by the SFC parser
    if (desc.script) {
        desc.script.content = desc.script.content.replace(/^(\/\/\n)+/, "");
    }
    return desc
}

/**
* Returns the SFC custom block for a given SFC sourcecode and custom block name
* @param source
* @param blockName
*/
const getCustomBlock = (descriptor, blockName) => {

    var blockIndex = descriptor.customBlocks.findIndex(customBlock => customBlock.type === blockName)

    if (blockIndex >= 0) {
        return descriptor.customBlocks[blockIndex]
    }
    else {
        return null
    }
}

/**
 * Given a SFC's descriptor, returns the SFC's source code
 * @param descriptor - SFC descriptor
 * @returns {string} - SFC source code
 */
const descriptorToHTML = descriptor =>
    descriptor.customBlocks
        .map(cb => blockToHTML(cb))
        .join("\n") +
    blockToHTML(descriptor.template) + "\n" + 
    blockToHTML(descriptor.script) + "\n" +
    descriptor.styles.map(cb => blockToHTML(cb));

/**
* Given a SFC block, returns the SFC's source **without** the template part
* @param descriptor - SFC descriptor
* @returns {string} - SFC source code
*/
function blockToHTML(block) {
    if (block) {
        let attrToHtmlAttr = ([key, value]) => ` ${key}="${value}"`;
        let attrs = Object.entries(block.attrs).reduce((accum, curr) => accum + attrToHtmlAttr(curr), "");
        return `<${block.type} ${attrs}>${block.content}</${block.type}>`;
    }
    else {
        return ''
    }
}

exports.descriptorToHTML = descriptorToHTML
exports.getCustomBlock = getCustomBlock
exports.toDescriptor = toDescriptor